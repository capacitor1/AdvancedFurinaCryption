# AdvancedFurinaCryption

<div align="center">
  <img width="100px" alt="logo" src="icon.jpg"/>
  <p><em>Furina Nya~</em></p>
</div>

---

一个简易的**伪**加密软件，提供高级的XOR文件加密，用于阻止*某些平台*和*某些地区的服务*对文件内容的审查和封禁。

*此软件不提供真正的安全加密，仅能够用于防止自动或智能程序窥探文件内容。不真正加密可防止用户忘记密码以及一系列因为密码而导致的麻烦。如果真正需要加密隐私，请使用`AES`系列加密方法*。

### 功能介绍

- 基本：对文件进行XOR加密，并自定义文件结构（`.afc`后缀）。

- 基本：在软件内：批量操作/拖拽添加文件/按`DEL`删除项目，简化加解密所需的步骤。

- 文件加密时采用密码表（字节数组）分别对文件字节进行XOR，而不是整体都用同一个byte。

  > 此法可防止*某些平台*能够对普通XOR之后的文件进行特征检测或暴力解密检测（因为XOR的byte最多255个）。

- 文件分段加密，可自定义block大小。每个block的密码表都不一样。

  > 密码表使用`RandomNumberGenerator`生成，每次生成都随机，即使同一个文件加密两次，密码都不一样，可防止*某些平台*进行人工举报+MD5检测。

- **文件乱序分块，不按照原文件顺序分块，而是随机乱序写入加密块**，文件被完全打乱。

  > 乱序分块可以防止*某些平台*能够对文件进行分块/特征检测，或者上人工检查。

- 支持仅分段的**不加密**模式。可节省一定的性能和时间。

- **可自定义key大小和block大小**来调整文件的安全性和加解密所需性能。

  > 在key大小特别小（为`16`时），安全性会减弱，此时特征检测可能会检测到文件。

  > 在block大小和key大小都特别小（都是`16`时），加密后的文件体积会增大数倍，且更耗时更费性能。*谨慎使用*

### 使用方法

> Huh? 有UI界面应该是傻瓜操作（

> 但是需要说明一些可能存在的误操作和错误输入

1. （必选）选择输出文件夹和文件。文件选择后应该显示在列表中。

2. （可选）自行修改key大小和block大小。

    > **注意：key和block大小都不得超过`int.MaxValue`，即 `2174783647`，超出这个值将无法开始加密操作。**

    > key大小必须是16的整数倍，如果不是则无法开始加密。

    > **注意：用户输入的block大小不是真实的block大小，真正的block大小是 `输入的大小 * key大小` ，故输入block大小时需要注意，`输入的大小 * key大小`不得超过`int.MaxValue`。

3. （可选）不加密 这个选项勾选后将不进行XOR操作，只根据block大小进行分块。

    > 注：即使勾选不加密，文件大小和加密后的是一致的，只是*存储key的部分全为0x00*

4. 点击 `加密` 或 `解密`。

    > 加密时可无限套娃操作，任何文件都可进行加密。但解密时不管文件列表里有什么文件，只会操作`.afc`后缀的文件。故解密文件前应该把要解密的文件后缀确定成`.afc`。

> 注：软件会检测重复的文件并自动重命名。不会覆盖或错误的追加已有文件。

### AFC文件

1. AFC文件头定义

|Offset|类型|名称|
|:-:|:-:|:-:|
|0x00|byte[]|文件头|
|0x08|long|AFC文件总长|
|0x10|long|原文件长度|
|0x18|long|分块数量|
|0x20|long|分块长度|
|0x28|long|key长度|
|0x30|byte[]|GUID|

其中，文件头长8bytes，GUID长16bytes。

2. Block头定义

|Offset|类型|名称|
|:-:|:-:|:-:|
|0x00|byte[]|文件头|
|0x08|long|Pad长度|
|0x10|long|blockID|
|0x18|long|block短MD5|

但是在当前版本中，pad长度和block短md5均未使用。

3. 用户注意：

    - 加密后的afc因为包含key和文件头，文件将会比原文件稍大。但是如果参数设置不当则可能更大。请合理设置加密的参数。

    - afc文件后缀像lzma/zstd等流的后缀一样，会直接添加在原文件后缀之后，如`xxx.mp4.afc`。不要删除afc后缀然后直接打开文件。重命名文件时也不要误删原始文件的后缀。

    - **不要在软件未加密完时关闭软件。**软件不会等到加密完之后才退出，或者询问用户是否现在退出。但是！未加密完的文件和加密完的文件看起来没有差别，并且确实可以解密。**但是这种文件实际上是错误的，解密得到的文件将不完整（即使文件大小正确）。**

# Furina.AdvancedFurinaCryption.cs

如果不使用提供的现成winform软件而是需要编写命令行软件或WPF软件，或者需要移植到Android等其他平台，则可以直接简单地调用`Furina.AdvancedFurinaCryption`。

### 引用此文件

非常简单（

```c#
using Furina;
```

### 简单地加/解密

简单加解密只需要提供输入和输出的文件路径。（目前不支持直接在`Stream`中操作。）

> 注：建议使用async/await调用，避免大文件时程序UI卡顿。也可使用多线程调用来加速处理（基于磁盘IO性能）。

```c#
//加密
string inputfile = @"L:\Data\24.11 档案莉音.mp4";
string outputfile = @"L:\Data\24.11 档案莉音.mp4.afc";

AdvancedFurinaCryption afc = new(FurinaCryption.Encrypt, inputfile, outputfile);
await afc.Enc();

//解密

AdvancedFurinaCryption afcdec = new(FurinaCryption.Decrypt, inputfile, outputfile);
await afcdec.Dec();
```

### 加密设置

在简单加密的基础上可以设置一些值，比如key和block大小。

文件头也可自定义，但必须为8字节（可以用long转换），自定义的文件头可以防止被*某些平台*检测到格式特征，也可以合并到其他的文件系统中使用。

```c#
int kl = 512;
int bl = 1048576;
byte[] h = {0xff , 0xff ,0x00 ,0x00 ,0x12 ,0x34 ,0x56 ,0x78};

afc.SetBlockLength(bl);
afc.SetKeyLength(kl);
afc.SetHeader(h);//设置文件头，限8字节，可随意自定义。
```

### 注意

- 直接调用此方法无需考虑`Dispose`，因为暂不提供stream操作，内部读写的stream会在完成操作之后自动关闭。

---
